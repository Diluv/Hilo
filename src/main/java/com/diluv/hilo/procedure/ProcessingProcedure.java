package com.diluv.hilo.procedure;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Stream;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.util.FileUtils;

import com.diluv.confluencia.database.record.ProjectFileRecord;
import com.diluv.hilo.data.FileData;
import com.diluv.hilo.processor.IProcessStep;

/**
 * Instances of this class represent a defined procedure for the processing and
 * handling for different types of files.
 */
public class ProcessingProcedure {

    /**
     * An ArrayList that holds all defined processing steps for the procedure.
     * Order of insertion is used as the execution order for the various
     * processing steps.
     */
    private final ArrayList<IProcessStep> processingSteps;

    /**
     * A logger that is used to report debug and error information generated as
     * the procedure is executed.
     */
    private final Logger log;

    /**
     * Creates a new procedure instance.
     *
     * @param log The logger to log debug and error information to.
     * @param steps The processing steps to initialize the procedure with.
     */
    public ProcessingProcedure (Logger log, IProcessStep... steps) {

        this.processingSteps = new ArrayList<>();
        this.log = log;
        this.addStep(steps);
    }

    public ProcessingProcedure addStep (IProcessStep... steps) {

        for (final IProcessStep step : steps) {

            this.processingSteps.add(step);
        }

        return this;
    }

    public FileData processFile (Path input, ProjectFileRecord queueData) {

        /**
         * SETUP
         */

        final Path workingDir;
        final String extension = FileUtils.getFileExtension(input.toFile());

        final FileData data = new FileData();
        data.id = queueData.getId();
        data.name = queueData.getName();
        data.createdAt = queueData.getCreatedAt();
        data.changelog = queueData.getChangelog();
        data.projectId = queueData.getProjectId();
        data.userId = queueData.getUserId();

        try {

            // A temporary working directory to hold any files generated by the
            // various processing steps. This directory will be deleted during
            // the cleanup step but can be used as a shared storage between
            // processing steps while the procedure is still active.
            workingDir = Files.createTempDirectory("Hilo-" + queueData.getId());
        }

        catch (final IOException e) {

            this.log.error("Procedure failed with a fatal error. Temporary directory could not be created.", e);
            return null;
        }

        /**
         * PROCESSING - Apply the various processing steps.
         */

        try {

            // Iterate the steps in the procedure. Unless the array has
            // intentionally been tampered with this is done following the order
            // of insertion.
            for (final IProcessStep step : this.processingSteps) {

                if (step.validate(this.log, data, queueData, input, extension)) {

                    step.process(this.log, data, queueData, workingDir, input, extension);
                }
            }
        }

        catch (final Exception e) {

            this.log.error("Procedure failed with a fatal error.", e);
        }

        /**
         * CLEANUP - Delete any original files and return to the original state.
         */

        // Once all processing steps have been completed, attempt to forcefully
        // delete the directory. This is done to save file space and also
        // prevent potential conflicts with working directories.
        try (Stream<Path> stream = Files.walk(workingDir)) {

            stream.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
        }

        catch (final IOException e) {

            this.log.error("Failed to delete working directory for {}.", workingDir);
            this.log.catching(e);
        }

        return data;
    }
}