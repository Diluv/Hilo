package com.diluv.hilo.procedure;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Stream;

import org.apache.logging.log4j.Logger;

import com.diluv.hilo.processor.IProcessStep;

/**
 * Instances of this class represent a defined procedure for the processing and
 * handling for different types of files.
 */
public class ProcessingProcedure {

    /**
     * An ArrayList that holds all defined processing steps for the procedure.
     * Order of insertion is used as the execution order for the various
     * processing steps.
     */
    private final ArrayList<IProcessStep> processingSteps;

    /**
     * A logger that is used to report debug and error information generated as
     * the procedure is executed.
     */
    private final Logger log;

    /**
     * Creates a new procedure instance.
     *
     * @param log The logger to log debug and error information to.
     * @param steps The processing steps to initialize the procedure with.
     */
    public ProcessingProcedure (Logger log, IProcessStep... steps) {

        this.processingSteps = new ArrayList<>();
        this.log = log;

        for (final IProcessStep step : steps) {

            this.processingSteps.add(step);
        }
    }

    public void processFile (Path input, long fileId) {

        /**
         * SETUP
         */

        final Path workingDir;

        try {

            // A temporary working directory to hold any files generated by the
            // various processing steps. This directory will be deleted during
            // the
            // cleanup step but can be used as a shared storage between
            // processing
            // steps while the procedure is still active.
            workingDir = Files.createTempDirectory("Hilo-" + fileId);
        }

        catch (final IOException e) {

            this.log.error("Procedure failed with a fatal error. Temporary directory could not be created.", e);
            return;
        }

        /**
         * PROCESSING - Apply the various processing steps.
         */

        try {

            // Iterate the steps in the procedure. Unless the array has
            // intentionally been tampered with this is done following the order
            // of insertion.
            for (final IProcessStep step : this.processingSteps) {

                if (step.validate(this.log, fileId, input)) {

                    step.process(this.log, fileId, workingDir, input);
                }
            }
        }

        catch (final Exception e) {

            this.log.error("Procedure failed with a fatal error.", e);
        }

        /**
         * CLEANUP - Delete any original files and return to the original state.
         */

        // Once all processing steps have been completed, attempt to forcefully
        // delete the directory. This is done to save file space and also
        // prevent potential conflicts with working directories.
        try (Stream<Path> stream = Files.walk(workingDir)) {

            stream.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
        }

        catch (final IOException e) {

            this.log.error("Failed to delete working directory for {}.", workingDir);
            this.log.catching(e);
        }
    }
}